<template>
  <div class="page" data-name="home">
    <!-- Top Navbar -->
    <div class="navbar">
      <div class="navbar-bg"></div>
      <div class="navbar-inner">
        <div class="title sliding">iAlbums</div>

        <!-- Add New Record Button -->
        <div class="right">
          <!-- Framework7 icon approach -->
          <a href="/details/new/" class="link nav-add-button">
            <i class="icon f7-icons if-not-md">plus</i>
            <i class="icon material-icons if-md">add</i>
          </a>
        </div>
      </div>
    </div>


    <!-- List Index -->
    <div class="list-index"></div>

    <div class="page-content">
      <div class="block">
        <p>La tua lista di Album!</p>
      </div>
      <div class="block">
        <div class="segmented segmented-strong">
          <button class="button" data-sort="title">Title</button>
          <button class="button" data-sort="author">Author</button>
          <button class="button" data-sort="rating">Rating</button>
          <span class="segmented-highlight"></span>
        </div>

      </div>


      <div class="list contacts-list">
        <!-- Album groups will be dynamically inserted here -->
      </div>
    </div>
  </div>
</template>

<script>
  export default function (props, { $f7, $onMounted, $onBeforeUnmount, $update, $store }) {

    let activeSort = 'title';
    let syncing = false; // Tracks whether sync is in progress

    const syncData = async () => {
      if (syncing) return; // Prevent multiple syncs

      console.info('I\'m Syncing')

      syncing = true;
      $update(); // Update the UI to show the spinner

      try {
        await $store.dispatch('fetchData'); // Trigger sync
        $f7.toast.create({
          text: 'Data synced successfully!',
          closeTimeout: 2000,
          closeButton: true,
        }).open();
      } catch (error) {
        console.error('Sync failed:', error);
        $f7.toast.create({
          text: 'Sync failed. Please try again later.',
          closeTimeout: 2000,
          closeButton: true,
        }).open();
      } finally {
        syncing = false;
        $update(); // Hide the spinner
      }
    };

    const setSort = (criterion) => {
      activeSort = criterion;
      sortAlbums();
      $update(); // Update the component to reflect changes
    };

    // Helper function to remove active class and set the new active button
    const setActiveButton = (activeButton) => {
      const segmentedButtons = document.querySelectorAll('.segmented .button');
      segmentedButtons.forEach((button) => button.classList.remove('button-active'));
      activeButton.classList.add('button-active');
    };

    const sortAlbums = (criterion) => {
      const albums = [...$store.getters.albums.value]; // Clone the albums array
      switch (criterion) {
        case 'title':
          albums.sort((a, b) => a.title.localeCompare(b.title));
          break;
        case 'author':
          albums.sort((a, b) => a.authors[0].localeCompare(b.authors[0]));
          break;
        case 'rating':
          albums.sort((a, b) => a.rating.localeCompare(b.rating));
          break;
        default:
          console.warn('Invalid sort criterion:', criterion, 'resorting to default');
          albums.sort((a, b) => a.title.localeCompare(b.title))
      }
      renderAlbums(albums);
    };

    const renderAlbums = (albums) => {
      console.log('rendering albums:', albums);
      const listEl = document.querySelector('.contacts-list');
      listEl.innerHTML = ''; // Clear existing content

      let groupedAlbums;

      if (activeSort === 'author') {
        // Group by first author
        groupedAlbums = albums.reduce((groups, album) => {
          const authorId = album.authors[0];
          const author = $store.getters.authors.value.find((a) => a.id === authorId);
          const authorNameLetter = author ? author.name[0].toUpperCase() : '-';
          if (!groups[authorNameLetter]) groups[authorNameLetter] = [];
          groups[authorNameLetter].push(album);
          return groups;
        }, {});
      } else if (activeSort === 'rating') {
        // Group by rating
        groupedAlbums = albums.reduce((groups, album) => {
          const letter = album.rating[0].toUpperCase() || 'No Rating';
          if (!groups[letter]) groups[letter] = [];
          groups[letter].push(album);
          return groups;
        }, {});
      } else {
        // Default grouping (by title's first letter)
        groupedAlbums = albums.reduce((groups, album) => {
          const letter = album.title[0].toUpperCase();
          if (!groups[letter]) groups[letter] = [];
          groups[letter].push(album);
          return groups;
        }, {});
      }

      // Get group indexes (sorted keys)
      const indexes = Object.keys(groupedAlbums).sort();

      // Populate the list with grouped albums
      indexes.forEach((key) => {
        const groupEl = document.createElement('div');
        groupEl.className = 'list-group';
        groupEl.innerHTML = `
      <ul>
        <li class="list-group-title">${key}</li>
        ${groupedAlbums[key]
            .map((album) => {
              const authorNames = album.authors
                .map((id) => {
                  const author = $store.getters.authors.value.find((a) => a.id === id);
                  return author ? author.name : 'Unknown Author';
                })
                .join(', ');

              return `
              <li>
                <a href="/details/${album.id}/" class="item-link item-content">
                  <div class="item-inner">
                    <div class="item-title">${album.title}</div>
                    <div class="item-after">
                      <span class="item-authors" style="max-width: 150px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${authorNames}</span>
                    </div>
                    <div class="item-rating">${album.rating}</div>
                  </div>
                </a>
              </li>`;
            })
            .join('')}
      </ul>
    `;
        listEl.appendChild(groupEl);
      });

      // Initialize the List Index
      const listIndexEl = document.querySelector('.list-index');
      const listIndex = $f7.listIndex.create({
        el: listIndexEl,
        listEl,
        indexes,
        scrollList: true,
        label: true,
      });
    };


    // Clicking the "+" button should navigate to /details/new
    const goToAddAlbum = () => {
      $f7.views.main.router.navigate('/details/new/');
    };

    // Lifecycle: On Mounted
    $onMounted(async () => {

      await syncData();


      $store.dispatch('loadLocalStorage'); // Load data from local storage
      sortAlbums(); // Initial sort and render



    });
    // Listen for pageBeforeIn every time user navigates back
    $f7.on('pageBeforeIn', (page) => {
      if (page.name === 'home') {
        $store.dispatch('loadLocalStorage');
        sortAlbums();
      }
    });


    let listIndex;

    // Lifecycle: On Before Unmount
    $onBeforeUnmount(() => {
      if (listIndex) listIndex.destroy();
      $f7.off('pageBeforeIn'); // Remove listener to avoid memory leaks
    });

    // Lifecycle: Page Init
    $f7.on('pageInit', (page) => {
      if (page.name === 'home') {
        const segmentedButtons = document.querySelectorAll('.segmented .button');

        // Add click event listeners to each button
        segmentedButtons.forEach((button) => {
          button.addEventListener('click', () => {
            const sortCriterion = button.dataset.sort;
            if (activeSort !== sortCriterion) {
              activeSort = sortCriterion;
              setActiveButton(button);

              // Call your sorting logic here
              console.log(`Sorting by: ${sortCriterion}`);
              sortAlbums(sortCriterion); // Pass activeSort to your sorting function
            }
          });
        });
      }
    });

    // Return the render function
    return $render;
  }

</script>
<style>
  /* Minimalistic rating styles */
  .item-rating {
    font-size: 18px;
    margin-left: 10px;
  }

  /* Improve spacing between authors and ratings */
  .item-authors {
    font-size: 14px;
    margin-right: 10px;
    color: #666;
    max-width: 150px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  /* Segmented controls */
  .segmented .button {
    text-transform: capitalize;
  }

  .segmented .button-active {
    font-weight: bold;
  }

  /* Sync button styles */
  .sync-button {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 8px;
    color: var(--f7-icon-color, #000);
  }

  .sync-button .preloader {
    margin-left: 5px;
  }

  /* Optional: Change sync icon color when active */
  .sync-button.syncing {
    color: var(--f7-color-primary);
  }

  /* "Add" button in the navbar */
  .nav-add-button {
    margin-right: 15px;
    display: flex;
    align-items: center;
  }

  .nav-add-button i {
    font-size: 24px;
  }
</style>